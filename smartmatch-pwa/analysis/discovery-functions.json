[
  {
    "name": "getThresholds",
    "type": "function",
    "code": "function getThresholds(type: string) {\r\n  const isSpecs = type.includes(\"specs\");\r\n  const isDxomark = type.includes(\"dxomark\");\r\n\r\n  if (isSpecs) {\r\n    return {\r\n      wordCount: { min: 500, max: 1200 },\r\n      fileSize: { min: 3, max: 6 },\r\n      minContentLength: 200,\r\n    };\r\n  }\r\n\r\n  if (isDxomark) {\r\n    return {\r\n      wordCount: { min: 200, max: 1000 },\r\n      fileSize: { min: 4, max: 12 },\r\n      minContentLength: 200,\r\n    };\r\n  }\r\n\r\n  // Review thresholds - compute max based on source\r\n  const maxWords =\r\n    type.includes(\"gsmarena\") || type.includes(\"notebookcheck\") ? 27000 :\r\n      type.includes(\"techradar\") ? 13500 :\r\n        type.includes(\"phonearena\") || type.includes(\"androidcentral\") ? 10500 :\r\n          type.includes(\"theverge\") ? 9000 : 7875;\r\n\r\n  return {\r\n    wordCount: { min: 2000, max: maxWords },\r\n    fileSize: { min: 12, max: 80 },\r\n    minContentLength: 500,\r\n  };\r\n}",
    "start": 4239,
    "end": 5147,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "cleanWhitespace",
    "type": "function",
    "code": "function cleanWhitespace(text: string): string {\r\n  return text\r\n    .replace(/[ \\t]+/g, \" \")\r\n    .replace(/^\\s+|\\s+$/gm, \"\")\r\n    .replace(/\\n{3,}/g, \"\\n\\n\")\r\n    .trim();\r\n}",
    "start": 10568,
    "end": 10744,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "loadFailureCache",
    "type": "function",
    "code": "function loadFailureCache(): FailureCache {\r\n  if (!existsSync(CONFIG.PATHS.FAILURE_CACHE)) {return {};}\r\n  try {\r\n    return JSON.parse(readFileSync(CONFIG.PATHS.FAILURE_CACHE, \"utf8\"));\r\n  } catch {\r\n    return {};\r\n  }\r\n}",
    "start": 15644,
    "end": 15868,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "saveFailureCache",
    "type": "function",
    "code": "function saveFailureCache(cache: FailureCache): void {\r\n  const tmpPath = `${CONFIG.PATHS.FAILURE_CACHE}.tmp`;\r\n  writeFileSync(tmpPath, JSON.stringify(cache, null, 2), \"utf8\");\r\n  renameSync(tmpPath, CONFIG.PATHS.FAILURE_CACHE);\r\n}",
    "start": 15917,
    "end": 16149,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "shouldSkipUrl",
    "type": "function",
    "code": "function shouldSkipUrl(cache: FailureCache, url: string): boolean {\r\n  const entry = cache[url];\r\n  if (!entry) { return false; }\r\n  if (entry.doNotRetry) { return true; }\r\n  return new Date(entry.nextRetry).getTime() > Date.now();\r\n}",
    "start": 16153,
    "end": 16387,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "cacheArchiveFailure",
    "type": "function",
    "code": "function cacheArchiveFailure(\r\n  cache: FailureCache,\r\n  url: string,\r\n  attemptedUrls?: string[],\r\n  cdxStrategy?: string,\r\n  failureReason?: ValidationFailureReason,\r\n): void {\r\n  const now = new Date();\r\n  const existing = cache[url];\r\n  const failureCount = existing ? existing.failureCount + 1 : 1;\r\n  const retryCount = existing ? existing.retryCount + 1 : 1;\r\n\r\n  const doNotRetry = failureReason === ValidationFailureReason.WRONG_TYPE;\r\n  const backoffHours = [1, 6, 24, 168, 720][Math.min(failureCount - 1, 4)] || 1;\r\n  const nextRetry = new Date(now.getTime() + backoffHours * 3600000);\r\n\r\n  const cacheEntry: FailureCacheEntry = {\r\n    failedAt: now.toISOString(),\r\n    failureCount,\r\n    nextRetry: nextRetry.toISOString(),\r\n    retryCount,\r\n    attemptedUrls: attemptedUrls || existing?.attemptedUrls || [],\r\n    cdxStrategy: cdxStrategy || existing?.cdxStrategy || \"recent\",\r\n    lastCdxCall: attemptedUrls ? now.toISOString() : (existing?.lastCdxCall || undefined),\r\n  };\r\n\r\n  if (doNotRetry || existing?.doNotRetry) {\r\n    cacheEntry.doNotRetry = true;\r\n  }\r\n  if (failureReason || existing?.failureReason) {\r\n    cacheEntry.failureReason = (failureReason as string) || (existing ? existing.failureReason : undefined) || \"\";\r\n  }\r\n\r\n  cache[url] = cacheEntry;\r\n  saveFailureCache(cache);\r\n}",
    "start": 16391,
    "end": 17697,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "loadNoSnapshotsCache",
    "type": "function",
    "code": "async function loadNoSnapshotsCache(): Promise<NoSnapshotsCache> {\r\n  try {\r\n    const cacheFile = pathModule.join(process.cwd(), \"data\", \"no_snapshots_cache.json\");\r\n    const data = await fs.readFile(cacheFile, \"utf8\");\r\n    return JSON.parse(data);\r\n  } catch {\r\n    return {};\r\n  }\r\n}",
    "start": 17737,
    "end": 18025,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "saveNoSnapshotsCache",
    "type": "function",
    "code": "async function saveNoSnapshotsCache(cache: NoSnapshotsCache): Promise<void> {\r\n  const cacheFile = pathModule.join(process.cwd(), \"data\", \"no_snapshots_cache.json\");\r\n  const tmpPath = `${cacheFile}.tmp`;\r\n  await fs.writeFile(tmpPath, JSON.stringify(cache, null, 2), \"utf8\");\r\n  await fs.rename(tmpPath, cacheFile);\r\n}",
    "start": 18029,
    "end": 18348,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "loadExtractionCache",
    "type": "function",
    "code": "async function loadExtractionCache(): Promise<ExtractionCache> {\r\n  try {\r\n    const cacheFile = pathModule.join(process.cwd(), \"data\", \"extraction_failures_cache.json\");\r\n    const data = await fs.readFile(cacheFile, \"utf8\");\r\n    return JSON.parse(data);\r\n  } catch {\r\n    return {};\r\n  }\r\n}",
    "start": 18395,
    "end": 18688,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "saveExtractionCache",
    "type": "function",
    "code": "async function saveExtractionCache(cache: ExtractionCache): Promise<void> {\r\n  const cacheFile = pathModule.join(process.cwd(), \"data\", \"extraction_failures_cache.json\");\r\n  const tmpPath = `${cacheFile}.tmp`;\r\n  await fs.writeFile(tmpPath, JSON.stringify(cache, null, 2), \"utf8\");\r\n  await fs.rename(tmpPath, cacheFile);\r\n}",
    "start": 18692,
    "end": 19016,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "requestArchiveSave",
    "type": "function",
    "code": "async function requestArchiveSave(url: string): Promise<boolean> {\r\n  const accessKey = process.env[\"IA_ACCESS_KEY\"];\r\n  const secretKey = process.env[\"IA_SECRET_KEY\"];\r\n\r\n  if (!accessKey || !secretKey) {\r\n    logger.warn(\"SAVE_API\", \"Archive.org credentials missing. Skipping save request.\");\r\n    return false;\r\n  }\r\n\r\n  logger.info(\"SAVE_API\", `Requesting Archive.org to save: ${url.slice(0, 60)}...`);\r\n\r\n  try {\r\n    const response = await fetch(\"https://web.archive.org/save/\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Accept\": \"application/json\",\r\n        \"Authorization\": `LOW ${accessKey}:${secretKey}`,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n        \"User-Agent\": \"SmartMatch Discovery Bot/1.0\",\r\n      },\r\n      body: `url=${encodeURIComponent(url)}`,\r\n      signal: AbortSignal.timeout(30000),\r\n    });\r\n\r\n    if (response.ok) {\r\n      logger.success(\"SAVE_API\", \"Archive save requested successfully\");\r\n      return true;\r\n    }\r\n\r\n    logger.warn(\"SAVE_API\", `Unexpected status: ${response.status}`);\r\n    return false;\r\n  } catch (e: unknown) {\r\n    logger.warn(\"SAVE_API\", `Save request failed: ${(e as Error).message}`);\r\n    return false;\r\n  }\r\n}",
    "start": 19131,
    "end": 20332,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "addDays",
    "type": "function",
    "code": "function addDays(dateStr: string, days: number): string {\r\n  const date = new Date(dateStr);\r\n  date.setDate(date.getDate() + days);\r\n  return date.toISOString().split(\"T\")[0] || \"\";\r\n}",
    "start": 20373,
    "end": 20558,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "createLogger",
    "type": "function",
    "code": "function createLogger(name: string) {\r\n  const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\").slice(0, -5);\r\n  const logFile = pathModule.join(CONFIG.PATHS.LOGS, `${name}_${timestamp}.log`);\r\n  const startTime = Date.now();\r\n\r\n  fs.mkdir(CONFIG.PATHS.LOGS, { recursive: true }).catch(() => { });\r\n\r\n  const write = (level: string, phase: string, msg: string, meta?: any) => {\r\n    const now = new Date();\r\n    const timeStr = now.toLocaleTimeString(\"en-US\", { hour12: false });\r\n    const elapsed = Date.now() - startTime;\r\n\r\n    const emoji = level === \"ERROR\" ? \"âŒ\" : level === \"WARNING\" ? \"âš ï¸\" :\r\n      level === \"SUCCESS\" ? \"âœ…\" : \"â„¹ï¸\";\r\n    const color = level === \"ERROR\" ? \"\\x1b[31m\" : level === \"WARNING\" ? \"\\x1b[33m\" :\r\n      level === \"SUCCESS\" ? \"\\x1b[32m\" : \"\\x1b[36m\";\r\n    const reset = \"\\x1b[0m\";\r\n\r\n    console.log(`${emoji} ${color}[${phase}]${reset} [${timeStr}] ${msg}`);\r\n\r\n    const entry = JSON.stringify({\r\n      timestamp: now.toISOString(),\r\n      level,\r\n      phase,\r\n      msg,\r\n      meta,\r\n      elapsed,\r\n    });\r\n    fs.appendFile(logFile, entry + \"\\n\", \"utf8\").catch(() => { });\r\n  };\r\n\r\n  return {\r\n    init: async () => {\r\n      try {\r\n        await fs.access(CONFIG.PATHS.LOGS, fsConstants.W_OK);\r\n      } catch {\r\n        console.error(`âŒ ERROR: Cannot write to log directory: ${CONFIG.PATHS.LOGS}`);\r\n      }\r\n    },\r\n    info: (phase: string, msg: string, meta?: any) => write(\"INFO\", phase, msg, meta),\r\n    success: (phase: string, msg: string, meta?: any) => write(\"SUCCESS\", phase, msg, meta),\r\n    warn: (phase: string, msg: string, meta?: any) => write(\"WARNING\", phase, msg, meta),\r\n    error: (phase: string, msg: string, meta?: any) => write(\"ERROR\", phase, msg, meta),\r\n  };\r\n}",
    "start": 20771,
    "end": 22508,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "createTelemetry",
    "type": "function",
    "code": "function createTelemetry(logger: ReturnType<typeof createLogger>) {\r\n  const metrics = {\r\n    cseCalls: 0,\r\n    archiveHits: 0,\r\n    scrapeSuccess: 0,\r\n    scrapeFailure: 0,\r\n    heroDownloads: 0,\r\n    heroSkipped: 0,\r\n    heroFailed: 0,\r\n    startTime: Date.now(),\r\n  };\r\n\r\n  return {\r\n    increment: (key: keyof Omit<typeof metrics, \"startTime\">) => {\r\n      metrics[key]++;\r\n    },\r\n    logSummary: () => {\r\n      const durationSeconds = (Date.now() - metrics.startTime) / 1000;\r\n      logger.info(\"TELEMETRY\", \"Session Summary\", metrics);\r\n      console.log(\"\\nðŸ“Š TELEMETRY SUMMARY\");\r\n      console.log(`   CSE Calls:         ${metrics.cseCalls}`);\r\n      console.log(`   Archive Hits:      ${metrics.archiveHits}`);\r\n      console.log(`   Scrape Success:    ${metrics.scrapeSuccess}/${metrics.scrapeSuccess + metrics.scrapeFailure}`);\r\n      console.log(`   Hero Images:       ${metrics.heroDownloads} downloaded, ${metrics.heroSkipped} cached, ${metrics.heroFailed} failed`);\r\n      console.log(`   Duration:          ${durationSeconds.toFixed(1)}s\\n`);\r\n    },\r\n  };\r\n}",
    "start": 22725,
    "end": 23802,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "constructor",
    "type": "function",
    "code": "\n\r\n  constructor() {\r\n    const httpsAgent = new https.Agent({ keepAlive: true });\r\n    const userAgent = CONFIG.USER_AGENTS[Math.floor(Math.random() * CONFIG.USER_AGENTS.length)];\r\n\r\n    this.client = axios.create({\r\n      timeout: CONFIG.TIMEOUTS.DEFAULT,\r\n      headers: {\r\n        \"User-Agent\": userAgent,\r\n        \"Accept\": \"text/html,application/json,*/*\",\r\n        \"Accept-Language\": \"en-US,en;q=0.9\",\r\n        \"Accept-Encoding\": \"gzip, deflate, br\",\r\n        \"DNT\": \"1\",\r\n        \"Connection\": \"keep-alive\",\r\n        \"Upgrade-Insecure-Requests\": \"1\",\r\n      } as Record<string, string>,\r\n      httpsAgent,\r\n    });\r\n\r\n    axiosRetry(this.client, {\r\n      retries: CONFIG.LIMITS.MAX_RETRIES,\r\n      retryDelay: axiosRetry.exponentialDelay,\r\n      retryCondition: (error) => {\r\n        return axiosRetry.isRetryableError(error) ||\r\n          (error.response?.status ? error.response.status >= 500 : false) ||\r\n          error.response?.status === 429;\r\n      },\r\n    });\r\n  }",
    "start": 24391,
    "end": 25372,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "normalizePath",
    "type": "function",
    "code": "\n\r\n  normalizePath(brand: string, model: string): string {\r\n    return pathModule.join(\r\n      CONFIG.PATHS.CONTENT,\r\n      `${brand}_${model}`.toLowerCase().replace(/\\s+/g, \"_\").replace(/[^\\w\\-_.]/g, \"\"),\r\n    );\r\n  }",
    "start": 39545,
    "end": 39763,
    "file": "scripts/discovery.ts"
  },
  {
    "name": "setupGracefulShutdown",
    "type": "function",
    "code": "function setupGracefulShutdown() {\r\n  const shutdown = async (signal: string) => {\r\n    console.log(`\\nðŸ›‘ Received ${signal}. Shutting down gracefully...`);\r\n    logger.warn(\"SYSTEM\", `Received ${signal}, shutting down`);\r\n    telemetry.logSummary();\r\n    process.exit(0);\r\n  };\r\n\r\n  process.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\r\n  process.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\r\n}",
    "start": 70701,
    "end": 71088,
    "file": "scripts/discovery.ts"
  }
]