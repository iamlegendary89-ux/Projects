#!/usr/bin/env node
/**
 * LZFOF v1.0 - Module 2: AI Variant Generator
 * 
 * Generates N alternative implementations of a function using AI.
 * Saves each variant to variants/<functionName>/v1.ts, v2.ts, etc.
 * 
 * Usage: node generator.ts <functionName> [numVariants=5]
 */

import fs from "fs";
import path from "path";

interface GeneratorConfig {
    functionName: string;
    originalCode: string;
    numVariants: number;
    outputDir: string;
}

// The Universal AI Prompt - works for any function
export function generatePrompt(code: string, numVariants: number = 5): string {
    return `Generate ${numVariants} alternative implementations of this function.

ORIGINAL CODE:
\`\`\`
${code}
\`\`\`

RULES:
1. Keep EXACT behavior identical - same inputs produce same outputs
2. Minimize line count and cognitive complexity
3. Optimize for readability AND performance
4. Avoid unnecessary abstractions
5. Do NOT change function signature (inputs/outputs)
6. Each variant should try a DIFFERENT approach:
   - v1: Simplify logic, reduce nesting
   - v2: Use more functional patterns (map/filter/reduce)
   - v3: Optimize for performance (caching, early returns)
   - v4: Reduce dependencies, use native APIs
   - v5: Maximum readability, self-documenting code

RESPONSE FORMAT:
Return exactly ${numVariants} code blocks, each starting with:
// VARIANT N: [brief description of approach]

Return ONLY the code, no explanations outside code blocks.`;
}

// Parse AI response into individual variants
export function parseVariants(response: string): Array<{ variant: number; description: string; code: string }> {
    const variants: Array<{ variant: number; description: string; code: string }> = [];

    // Match: // VARIANT N: description\n...code...
    const variantPattern = /\/\/\s*VARIANT\s*(\d+)\s*:\s*([^\n]+)\n([\s\S]*?)(?=\/\/\s*VARIANT\s*\d+|$)/gi;

    let match: RegExpExecArray | null;
    while ((match = variantPattern.exec(response)) !== null) {
        variants.push({
            variant: parseInt(match[1]),
            description: match[2].trim(),
            code: match[3].trim(),
        });
    }

    // Fallback: just split by code blocks
    if (variants.length === 0) {
        const codeBlocks = response.match(/```(?:typescript|javascript|ts|js)?\n([\s\S]*?)```/g) || [];
        codeBlocks.forEach((block, i) => {
            const code = block.replace(/```(?:typescript|javascript|ts|js)?\n?/g, "").replace(/```$/g, "").trim();
            variants.push({
                variant: i + 1,
                description: `Alternative ${i + 1}`,
                code,
            });
        });
    }

    return variants;
}

// Save variants to disk
export async function saveVariants(config: GeneratorConfig, variants: Array<{ variant: number; description: string; code: string }>): Promise<string[]> {
    const variantDir = path.join(config.outputDir, config.functionName);

    // Create directory
    if (!fs.existsSync(variantDir)) {
        fs.mkdirSync(variantDir, { recursive: true });
    }

    // Save original as v0
    const originalPath = path.join(variantDir, "v0-original.ts");
    fs.writeFileSync(originalPath, `// ORIGINAL: Production implementation\n${config.originalCode}`);

    const savedPaths: string[] = [originalPath];

    // Save each variant
    for (const v of variants) {
        const filePath = path.join(variantDir, `v${v.variant}.ts`);
        const header = `// VARIANT ${v.variant}: ${v.description}\n// Generated by LZFOF v1.0\n\n`;
        fs.writeFileSync(filePath, header + v.code);
        savedPaths.push(filePath);
    }

    return savedPaths;
}

// Generate metadata file for the function
export function saveMetadata(config: GeneratorConfig, variants: Array<{ variant: number; description: string; code: string }>): void {
    const variantDir = path.join(config.outputDir, config.functionName);
    const metadata = {
        functionName: config.functionName,
        generatedAt: new Date().toISOString(),
        originalLines: config.originalCode.split("\n").length,
        variants: variants.map(v => ({
            id: `v${v.variant}`,
            description: v.description,
            lines: v.code.split("\n").length,
        })),
        status: "pending_tests",
    };

    fs.writeFileSync(
        path.join(variantDir, "metadata.json"),
        JSON.stringify(metadata, null, 2)
    );
}

// CLI helper - prints the prompt for user to send to AI
export function printPromptForAI(functionCode: string, numVariants: number = 5): void {
    console.log("=".repeat(60));
    console.log("ðŸ“‹ COPY THIS PROMPT TO YOUR AI:");
    console.log("=".repeat(60));
    console.log(generatePrompt(functionCode, numVariants));
    console.log("=".repeat(60));
    console.log("\nðŸ’¡ After getting response, save it to a file and run:");
    console.log("   npx tsx framework/generator.ts parse <response.txt> <functionName>\n");
}

// Main CLI
if (process.argv[1]?.includes("generator")) {
    const args = process.argv.slice(2);

    if (args[0] === "prompt" && args[1]) {
        // Generate prompt from function code
        const code = fs.readFileSync(args[1], "utf8");
        const numVariants = parseInt(args[2]) || 5;
        printPromptForAI(code, numVariants);
    } else if (args[0] === "parse" && args[1] && args[2]) {
        // Parse AI response and save variants
        const response = fs.readFileSync(args[1], "utf8");
        const functionName = args[2];
        const originalCode = args[3] ? fs.readFileSync(args[3], "utf8") : "// Original not provided";

        const variants = parseVariants(response);
        const config: GeneratorConfig = {
            functionName,
            originalCode,
            numVariants: variants.length,
            outputDir: "./variants",
        };

        saveVariants(config, variants);
        saveMetadata(config, variants);

        console.log(`âœ… Saved ${variants.length} variants to variants/${functionName}/`);
    } else {
        console.log("Usage:");
        console.log("  Generate prompt:  npx tsx generator.ts prompt <function.ts> [numVariants]");
        console.log("  Parse response:   npx tsx generator.ts parse <response.txt> <functionName> [original.ts]");
    }
}

export { generatePrompt as default };
